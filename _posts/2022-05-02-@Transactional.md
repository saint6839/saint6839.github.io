# @Transactional

기존에 `@Transactional`을 테스트 코드를 작성할 때, 실제 데이터베이스에 올라가지 않도록 롤백을 시키는 용도로만 사용하였다. 그러나 이번에 새싹에서 진행한 웹 미션의 코드 리뷰를 통해서 다른 기능들이 더 있는것 같아 추가적으로 찾아보고 정리하게 되었다.

### Transaction 이란?

먼저 트랜잭션이 무엇인지에 대해서 알아보자. 데이터베이스 트랜잭션이란 데이터베이스 관리 시스템 또는 유사한 시스템에서 상호작용의 더 이상 쪼개질 수 없는 최소 연산 단위이다.

트랜잭션 특징은 **ACID**라고 한다

- **원자성(Atomic)**

  트랜잭션과 관련도니 작업들이 부분적으로 실행되다가 중단되지 않는 것을 보장하는 능력이다. 예를 들어 돈을 이체하고 꺼내는 과정에서, 한쪽만 성공하고 다른 한쪽이 실패해서는 안된다. 원자성은 이 처럼 중간 단계까지 실행되고 실패하는 일이 없도록 한다.

  즉 한 트랜잭션 내에서 실행한 작업들은 하나의 단위로 처리해야한다. 즉 모두 성공하거나 모두 실패해야 한다.

- **일관성(Consistencty)**

  트랜잭션이 실행을 성공하면 언제나 일관성있는 데이터베이스 상태를 유지한다.

- **독립성(Isolation)**

  트랜잭션 수행 시 다른 트랜잭션 연산 작업이 끼어들지 못하도록 보장하는 것을 의미한다. 즉 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 못한다.

- **영속성(Durability)**

  트랜잭션을 성공적으로 마치면 결과가 항상 저장되어야 한다.



### @Transactional

​	스프링에서는 트랜잭션 처리를 지원하는데 `@Transactional` 을 선언해서 사용이 가능하며, 이를 **선언적 트랜잭션**이라고 부른다. 클래스나 메서드 위에 `@Transactional`이 추가되면 트랜잭션 기능이 적용된 프록시 객체가 생성된다.

이 프록시 객체는 `@Transactional`이 포함된 메서드가 호출될 경우, `PlatofromTransactionManager`를 사용해서 트랜잭션을 시작하고, 정상 여부에 따라 Commit 또는 Rollback 한다.

```java
@Transactional
public void save() {
  ...
}
```

### 격리 수준에 따라 발생할 수 있는 문제

| 격리 수준        | Dirty Read | Non-Repeatable Read | Phantom Read |
| ---------------- | ---------- | ------------------- | ------------ |
| Read Uncommitted | O          | O                   | O            |
| Read Committed   | -          | O                   | O            |
| Repeatable Read  | -          | -                   | O            |
| Serializable     | -          | -                   | -            |

- **Dirty Read**

  아직 트랜잭션이 완료되지 않은 상황에서 데이터에 접근을 허용할 경우 생기는 데이터 불일치 문제이다.

  트랜잭션1이 수정중인 데이터를 트랜잭션2가 읽을 수 있다. 만약 트랜잭션1의 값이 정상 커밋되지 않고 롤백되면, 트랜잭션2가 롤백 전에 읽은 값은 잘못된 데이터가 된다.

- **Non-Repeatable Read**

  한 트랜잭션이 같은 쿼리를 두 번 실행했을때 발생할 수 있는 데이터 불일치 문제이다.

  트랜잭션1이 회원 A를 조회하던 중에 트랜잭션2가 회원 A의 정보를 수정하고 커밋하면 트랜잭션 1이 다시 회원 A를 조회했을 경우에는 수정된 데이터가 조회된다. 즉 반복해서 같은 데이터를 읽을 수 없는 경우에 해당한다.

- **Phantom Read**

  트랙잭션이1이 전자기기 카테고리를 조회했는데, 트랜잭션2가 컴퓨터를 추가하고 조회하면 트랜잭션1이 다시 전자기기 카테고리를 조회했을 때 상품 하나가 추가된 상태로 조회된다. 반복 조회시 결과 집합이 달라지는 경우에 해당한다.

격리 수준이 높아질 수록 데이터 무결성을 유지할 수 있다. 하지만 무조건 상위 격리 수준을 사용할 경우 **Locking**으로 인해 동시에 수행되는 많은 트랜잭션들이 순차 처리되면서 DB의 성능이 떨어진다. 그렇다고 **Locking**의 범위를 줄이게 되면 잘못된 값이 처리될 가능성도 생기므로 적절하게 잘 사용하는 것이 중요하다.



> 참고자료
>
> - https://goddaehee.tistory.com/167
> - https://ko.wikipedia.org/wiki/ACID
> - https://velog.io/@kdhyo/JavaTransactional-Annotation-%EC%95%8C%EA%B3%A0-%EC%93%B0%EC%9E%90-26her30h

